"use strict";
const EventEmitter = require('events');
const fs = require('fs');
var app = require('express')();
var http = require('http').Server(app);
var io = require('socket.io')(http);
const util = require('util');
const exec = util.promisify(require('child_process').exec);
exec('node "'+__dirname+'/logs/log.js"',function(err, stdout, stderr){console.log(err)});
class Tank extends EventEmitter {
	constructor(height, radius, maxValveRadius, inlet, highLevelSensor, lowLevelSensor, port){
		super();
		this.IO = io;
		this.port = port;
		this.height=0;
		this.tankHeight = height;
		this.radius = radius;
		this.valveRadius = 0;
		this.maxValveRadius=maxValveRadius;
		this.valveArea = null;
		this.inlet = inlet;
		this.tankCrossArea = Math.PI*radius*radius;
		this.model=null;
		this.highLevelSensor=highLevelSensor;
		this.lowLevelSensor=lowLevelSensor; 
		http.listen(port, function(){});
		var self = this;
		app.get('/model', function(req, res){
			res.send(self.getHTMLVisualization());
		});
		this.IO.on('connection', function(socket){
			console.log('view is connected !!');
		});
	}
	
	startExperiment(){
		this.IO.emit('command',{title:'start'});
		var x;
		var self = this;
		this.model = setInterval(function(){
			self.valveArea = Math.PI*self.valveRadius*self.valveRadius;
			x=0.01*(self.valveArea/self.tankCrossArea)*Math.sqrt(2*9.81*self.height);
			self.height=self.height-x+self.inlet;
			if(self.height < 0)
				self.height = 0;
			if(self.height > self.tankHeight)
				self.height = self.tankHeight;
			if(self.height>self.tankHeight*self.highLevelSensor)
				self.emit('HIGH_LEVEL',self.height);
			if(self.height<self.tankHeight*self.lowLevelSensor)
				self.emit('LOW_LEVEL',self.height);
			self.IO.emit('data', {level:self.height/10, valve:(self.valveRadius/self.maxValveRadius)});
			
		},10);
	}
	
	stopExperiment(){
		if(this.model === null)
			return null;
		clearInterval(this.model);
		
	}
	
	getLevel(){return this.height;}
	
	setValve(value){
		this.valveRadius=this.maxValveRadius*value;
	}
	
	getValve(){
		return this.valveRadius/this.maxValveRadius;
	}
	
	setInlet(value){
		this.inlet=value;
	}
	
	getInlet(){
		return this.inlet;
	}
	
	getHTMLVisualization(){
		var aa=fs.readFileSync(__dirname+'/tank.html','utf-8');
		aa = aa.replace(/VAR-HIGHLEVELSENSOR/g,this.highLevelSensor);
		aa = aa.replace(/VAR-LOWLEVELSENSOR/g,this.lowLevelSensor);
		aa = aa.replace(/VAR-TANKRADIUS/g,this.tankHeight);
		aa = aa.replace(/VAR-DRAINRADIUS/g,this.tankHeight);
		return aa;
	}
}












module.exports = Tank;